# Devon Implementation Prompt: Feature 1, Task 1, Subtask 2 – Tool Orchestrator (Conversation Manager)

## Overview
Implement the `ToolOrchestrator` that manages the multi‑turn loop: calls the adapter, executes tool calls via `ToolRunner`, appends tool results to messages, and emits trace events.

## Goal
Create `backend/src/orchestration/ToolOrchestrator.js` that:
- Takes an adapter instance, tool registry, and options (`maxTurns`, `traceEmitter`).
- Runs a loop: call adapter → if `tool_calls` present, execute via `ToolRunner` → append tool results to messages → repeat until completion or max turns.
- Emits trace events for `llm_call`, `tool_call`, `tool_result`, `reasoning_content`.
- Returns final content and an array of trace events.

## Context
Tara has already written the test suite (`backend/src/orchestration/__tests__/ToolOrchestrator.spec.js`). All tests must pass. Refer to the test file for detailed expectations.

## Implementation Requirements

### 1. Class Structure
- Class name: `ToolOrchestrator`
- Constructor parameters:
  - `adapter` (instance of `DS_ReasonerAdapter`)
  - `toolRegistry` (object mapping tool names to tool definitions)
  - `options` (optional) – `maxTurns` (default 10), `traceEmitter` (function), `toolRunner` (instance of `ToolRunner`, defaults to new `ToolRunner(toolRegistry)`)
- Public method: `run(messages, systemPrompt)` – returns `Promise<{ content: string, traces: Array }>`

### 2. Loop Logic
1. Initialize `traces = []`, `turn = 0`.
2. While `turn < maxTurns`:
   - Call `adapter.call(messages, tools)` where `tools` are derived from `toolRegistry` (OpenAI‑style function definitions).
   - Emit `llm_call` trace with `messages` and the response (including `reasoning_content`).
   - If response has `tool_calls` array (length > 0):
     - Emit `tool_call` trace for each tool call.
     - Execute all tool calls via `toolRunner.executeToolCalls(toolRegistry, toolCalls, context)` where `context` includes `projectId`, `requestId`, `turnIndex`.
     - For each result in the returned array:
       - Emit `tool_result` trace.
       - Append tool result message to `messages` (role `tool`, content = JSON.stringify(result.result || result.error), tool_call_id = result.toolCallId).
     - Increment turn, continue loop.
   - Else (no tool calls):
     - Return `{ content: response.content, traces }`.

### 3. Trace Emission
- If `options.traceEmitter` is provided, call it with event object.
- Otherwise, collect events in `traces` array (default behavior).
- Event shape:
  ```javascript
  {
    type: 'llm_call' | 'tool_call' | 'tool_result',
    timestamp: Date.now(),
    data: { ... } // depends on type
  }
  ```
- For `llm_call`, include `response.reasoning_content` in `data`.

### 4. Tool Execution
- Use `ToolRunner` from `backend/tools/ToolRunner.js` (already exists).
- Tool registry must be passed to `ToolRunner` constructor.
- Handle tool execution errors: catch and produce a tool result with error message (still emit `tool_result` trace).

### 5. Message Format
- Initial `messages` array (includes system prompt as first message with role `system`).
- Tool result messages must follow OpenAI format:
  ```javascript
  {
    role: 'tool',
    content: JSON.stringify(result),
    tool_call_id: toolCall.id
  }
  ```

### 6. Edge Cases
- **Empty tool registry**: adapter receives empty tools array.
- **Max turns exceeded**: stop loop, return last response content and traces.
- **Multiple tool calls in one turn**: execute sequentially, collect all results, then append all tool result messages.
- **Tool execution error**: result should be `{ error: message }`; still append as tool result.
- **Adapter returns `null` content**: treat as empty string.

### 7. Dependencies
- `DS_ReasonerAdapter` (from subtask 1‑1‑1) – already implemented.
- `ToolRunner` and `functionDefinitions` (existing).
- Tool registry: can be built from `functionDefinitions` (see `backend/tools/functionDefinitions.js`).

## Deliverables
1. `backend/src/orchestration/ToolOrchestrator.js` – the orchestrator implementation.
2. Ensure all Tara’s tests pass (`npm test` in `backend` directory).
3. Create incremental probe `probe_1_1_2_tool_orchestrator.js` in `backend/scripts/probes/` that demonstrates the orchestrator working with the adapter and a single tool call.

## Notes
- This is a **conversation manager** – it does not know about specific tools, only delegates to `ToolRunner`.
- The orchestrator must be stateless per run (except for configuration).
- Follow existing code style (ES6 classes, async/await, JSDoc comments).
- The test suite is your guide; if a test fails, adjust your implementation accordingly.
- Refer to the approved ADR (`ADR-2025-12-29-modular-architecture-with-skills.md`) for architectural decisions.

---

*Prompt created by Adam (Architect) on 2025‑12‑30.*
