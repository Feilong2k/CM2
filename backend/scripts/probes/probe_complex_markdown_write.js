/**
 * Probe to test writing a complex markdown file (like Feature2 proposal)
 * to verify safeParseArgs handles complex JSON arguments.
 */

const { parseFunctionCall } = require('../../tools/functionDefinitions');
const fileSystemTool = require('../../tools/FileSystemTool');

async function testComplexMarkdownWrite() {
  console.log('=== Testing complex markdown write ===\n');
  
  // Complex markdown content similar to Feature2 proposal
  const complexMarkdown = `# Feature 2 Proposal: Aider Orchestration & Skills Framework (v1.1)

## Overview
**Title:** Autonomous TDD Workflow with Aider Integration
**Objective:** Enable Orion to coordinate TaraAider (testing) and DevonAider (implementation) through a structured skills framework and helper services.

## Core Problem Statement
Orion can decompose features and manage tasks, but cannot delegate single-file implementation/testing work to specialized Aider agents.

## Key Constraints
1. **Aiders cannot read files** - Context must be provided in prompts
2. **Aiders cannot run tests** - Separate test runner needed
3. **Concurrent file edits risk** - Need file locking or serialization
4. **Aider response format unspecified** - Need standardized schema
5. **No error handling/rollback** - Need robust failure recovery

## Tasks
### Task 2-1: Database Extensions for Step Management
**Description:** Create database tables to track single-file steps.

### Task 2-2: Core Helper Services
**Description:** Build the essential helper services for step decomposition and context building.

## Success Metrics
1. **Step Completion Rate:** >80% without manual intervention
2. **Test Pass Rate:** Maintain or improve existing test pass rates
3. **Error Recovery:** >90% of errors handled automatically
4. **Development Velocity:** 2x faster subtask completion

---
*Generated by probe_complex_markdown_write.js*`;

  // Simulate the tool call arguments that Orion would generate
  const toolCallArgs = JSON.stringify({
    path: 'test_complex_markdown.md',
    content: complexMarkdown
  });

  console.log('1. Testing parseFunctionCall with complex markdown...');
  const toolCall = {
    function: {
      name: 'FileSystemTool_write_to_file',
      arguments: toolCallArgs
    }
  };

  try {
    const parsed = parseFunctionCall(toolCall);
    console.log('✅ parseFunctionCall succeeded');
    console.log(`   Path: ${parsed.params.path}`);
    console.log(`   Content length: ${parsed.params.content.length} characters`);
    
    // Now actually write the file using FileSystemTool
    console.log('\n2. Actually writing file with FileSystemTool...');
    const writeResult = await fileSystemTool.tools.write_to_file({
      path: 'test_complex_markdown.md',
      content: complexMarkdown
    });
    console.log(`✅ File write succeeded: ${writeResult}`);
    
    // Read it back
    console.log('\n3. Reading file back to verify...');
    const readResult = await fileSystemTool.tools.read_file({
      path: 'test_complex_markdown.md'
    });
    
    if (readResult === complexMarkdown) {
      console.log('✅ File read back successfully, content matches.');
    } else {
      console.log('❌ Content mismatch!');
      console.log(`Expected length: ${complexMarkdown.length}, Got length: ${readResult.length}`);
    }
    
    // Clean up
    console.log('\n4. Cleaning up test file...');
    // No delete tool, so we'll just note it exists
    console.log('   Test file created at: test_complex_markdown.md');
    console.log('   (No delete tool available, file remains)');
    
    return true;
  } catch (error) {
    console.error('❌ Test failed:', error.message);
    console.error(error.stack);
    return false;
  }
}

if (require.main === module) {
  testComplexMarkdownWrite()
    .then(success => {
      console.log(`\n=== Test ${success ? 'PASSED' : 'FAILED'} ===`);
      process.exit(success ? 0 : 1);
    })
    .catch(err => {
      console.error('Unhandled error:', err);
      process.exit(1);
    });
} else {
  module.exports = { testComplexMarkdownWrite };
}
