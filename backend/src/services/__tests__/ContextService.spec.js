// We are testing the ContextService, which does not exist yet.
// We'll mock its dependencies.

jest.mock('../FileTreeContextBuilder');
jest.mock('../PromptTemplateService');
jest.mock('../HistoryLoaderService');

const FileTreeContextBuilder = require('../FileTreeContextBuilder');
const PromptTemplateService = require('../PromptTemplateService');
const HistoryLoaderService = require('../HistoryLoaderService');
const ContextService = require('../ContextService');

describe('ContextService', () => {
  let contextService;
  const mockFileTreeBuilder = {
    buildTree: jest.fn(),
  };
  const mockPromptTemplateService = {
    loadTemplate: jest.fn(),
  };
  const mockHistoryLoaderService = {
    loadRecentChatHistory: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset the mocks to return default values
    FileTreeContextBuilder.mockImplementation(() => mockFileTreeBuilder);
    PromptTemplateService.mockImplementation(() => mockPromptTemplateService);
    HistoryLoaderService.mockImplementation(() => mockHistoryLoaderService);

    contextService = new ContextService();
  });

  describe('Test 1: Full Integration Flow', () => {
    it('should orchestrate sub-services to build context and system prompt', async () => {
      const projectId = 'P1';
      const rootPath = '/mock/root';

      // Mock return values
      const mockFileTree = 'src/index.js\nsrc/utils/helper.js';
      const mockHistory = [
        { sender: 'user', content: 'Hello' },
        { sender: 'orion', content: 'Hi there' },
      ];
      const mockHistorySummary = 'Last 2 messages: Hello, Hi there';
      const mockProjectState = 'Active';
      const mockSystemPrompt = 'Filled template with file tree and history';

      mockFileTreeBuilder.buildTree.mockResolvedValue(mockFileTree);
      mockHistoryLoaderService.loadRecentChatHistory.mockResolvedValue(mockHistory);
      // In the real implementation, the history summary is generated by the ContextService.
      // We'll assume the service creates a summary string. For the test, we can mock the behavior
      // by spying on the service method, but we can also let the real method run.
      // Since the service doesn't exist, we'll just mock the dependencies and check that they are called correctly.

      // We need to define what the service does with the history. The spec says:
      //   Generate a "history summary" string (simple concatenation or "Last N messages...").
      // We'll assume the service creates a summary. We'll mock the service method? Actually we are testing the service.
      // We'll let the service do its job once implemented, but for now we can only test the calls.
      // However, we can mock the dependencies and then mock the service's internal method? That's too much.
      // Instead, we'll write the test to verify that the dependencies are called and that the prompt service is called with the expected context.

      // We'll set up the mock for loadTemplate to return the mockSystemPrompt.
      mockPromptTemplateService.loadTemplate.mockReturnValue(mockSystemPrompt);

      // Call the method
      const result = await contextService.buildContext(projectId, rootPath);

      // Verify the calls
      expect(mockFileTreeBuilder.buildTree).toHaveBeenCalledWith(rootPath, {
        maxDepth: 2,
        maxLines: 50,
      });
      expect(mockHistoryLoaderService.loadRecentChatHistory).toHaveBeenCalledWith({
        projectId,
        limit: 10,
      });
      // Check that the prompt template service was called with the correct context.
      // We need to know what context the service passes. It should include:
      //   file_tree, history_summary, project_state
      // We can check that the call includes these keys and that the values are derived from the mocks.

      // Since we don't know the exact history summary string, we can check that the call includes a string for history_summary.
      const templateCall = mockPromptTemplateService.loadTemplate.mock.calls[0];
      expect(templateCall[0]).toBe('orion_system.md');
      const context = templateCall[1];
      expect(context.file_tree).toBe(mockFileTree);
      // The history_summary should be a string (we can check type)
      expect(typeof context.history_summary).toBe('string');
      expect(context.project_state).toBe(mockProjectState); // or maybe it's derived? For now, we assume a placeholder.

      // Verify the result structure
      expect(result).toEqual({
        systemPrompt: mockSystemPrompt,
        contextData: {
          file_tree: mockFileTree,
          history_summary: context.history_summary,
          project_state: mockProjectState,
        },
      });
    });
  });

  describe('Test 2: Error Handling', () => {
    it('should fail loud when FileTreeContextBuilder throws', async () => {
      const projectId = 'P1';
      const rootPath = '/mock/root';
      const mockError = new Error('Failed to build tree');

      mockFileTreeBuilder.buildTree.mockRejectedValue(mockError);

      await expect(contextService.buildContext(projectId, rootPath)).rejects.toThrow(mockError);

      // Ensure that if the file tree fails, we don't proceed to load history or template.
      expect(mockHistoryLoaderService.loadRecentChatHistory).not.toHaveBeenCalled();
      expect(mockPromptTemplateService.loadTemplate).not.toHaveBeenCalled();
    });

    it('should fail loud when HistoryLoaderService throws', async () => {
      const projectId = 'P1';
      const rootPath = '/mock/root';
      const mockError = new Error('Failed to load history');

      mockFileTreeBuilder.buildTree.mockResolvedValue('some tree');
      mockHistoryLoaderService.loadRecentChatHistory.mockRejectedValue(mockError);

      await expect(contextService.buildContext(projectId, rootPath)).rejects.toThrow(mockError);

      // The file tree succeeded, but history failed, so we should not call the template.
      expect(mockPromptTemplateService.loadTemplate).not.toHaveBeenCalled();
    });
  });
});
